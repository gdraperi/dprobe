// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package triegen_test

import (
	"fmt"
	"io/ioutil"
	"math/rand"
	"unicode"

	"golang.org/x/text/internal/triegen"
)

const seed = 0x12345

var genWriter = ioutil.Discard

func randomRunes() map[rune]uint8 ***REMOVED***
	rnd := rand.New(rand.NewSource(seed))
	m := map[rune]uint8***REMOVED******REMOVED***
	for len(m) < 100 ***REMOVED***
		// Only set our random rune if it is a valid Unicode code point.
		if r := rune(rnd.Int31n(unicode.MaxRune + 1)); []rune(string(r))[0] == r ***REMOVED***
			m[r] = 1
		***REMOVED***
	***REMOVED***
	return m
***REMOVED***

// Example_build shows how to build a simple trie. It assigns the value 1 to
// 100 random runes generated by randomRunes.
func Example_build() ***REMOVED***
	t := triegen.NewTrie("rand")

	for r, _ := range randomRunes() ***REMOVED***
		t.Insert(r, 1)
	***REMOVED***
	sz, err := t.Gen(genWriter)

	fmt.Printf("Trie size: %d bytes\n", sz)
	fmt.Printf("Error:     %v\n", err)

	// Output:
	// Trie size: 9280 bytes
	// Error:     <nil>
***REMOVED***

// Example_lookup demonstrates how to use the trie generated by Example_build.
func Example_lookup() ***REMOVED***
	trie := newRandTrie(0)

	// The same set of runes used by Example_build.
	runes := randomRunes()

	// Verify the right value is returned for all runes.
	for r := rune(0); r <= unicode.MaxRune; r++ ***REMOVED***
		// Note that the return type of lookup is uint8.
		if v, _ := trie.lookupString(string(r)); v != runes[r] ***REMOVED***
			fmt.Println("FAILURE")
			return
		***REMOVED***
	***REMOVED***
	fmt.Println("SUCCESS")

	// Output:
	// SUCCESS
***REMOVED***

// runeValues generates some random values for a set of interesting runes.
func runeValues() map[rune]uint64 ***REMOVED***
	rnd := rand.New(rand.NewSource(seed))
	m := map[rune]uint64***REMOVED******REMOVED***
	for p := 4; p <= unicode.MaxRune; p <<= 1 ***REMOVED***
		for d := -1; d <= 1; d++ ***REMOVED***
			m[rune(p+d)] = uint64(rnd.Int63())
		***REMOVED***
	***REMOVED***
	return m
***REMOVED***

// ExampleGen_build demonstrates the creation of multiple tries sharing common
// blocks. ExampleGen_lookup demonstrates how to use the generated tries.
func ExampleGen_build() ***REMOVED***
	var tries []*triegen.Trie

	rv := runeValues()
	for _, c := range []struct ***REMOVED***
		include func(rune) bool
		name    string
	***REMOVED******REMOVED***
		***REMOVED***func(r rune) bool ***REMOVED*** return true ***REMOVED***, "all"***REMOVED***,
		***REMOVED***func(r rune) bool ***REMOVED*** return r < 0x80 ***REMOVED***, "ASCII only"***REMOVED***,
		***REMOVED***func(r rune) bool ***REMOVED*** return r < 0x80 ***REMOVED***, "ASCII only 2"***REMOVED***,
		***REMOVED***func(r rune) bool ***REMOVED*** return r <= 0xFFFF ***REMOVED***, "BMP only"***REMOVED***,
		***REMOVED***func(r rune) bool ***REMOVED*** return r > 0xFFFF ***REMOVED***, "No BMP"***REMOVED***,
	***REMOVED*** ***REMOVED***
		t := triegen.NewTrie(c.name)
		tries = append(tries, t)

		for r, v := range rv ***REMOVED***
			if c.include(r) ***REMOVED***
				t.Insert(r, v)
			***REMOVED***
		***REMOVED***
	***REMOVED***
	sz, err := triegen.Gen(genWriter, "multi", tries)

	fmt.Printf("Trie size: %d bytes\n", sz)
	fmt.Printf("Error:     %v\n", err)

	// Output:
	// Trie size: 18250 bytes
	// Error:     <nil>
***REMOVED***

// ExampleGen_lookup shows how to look up values in the trie generated by
// ExampleGen_build.
func ExampleGen_lookup() ***REMOVED***
	rv := runeValues()
	for i, include := range []func(rune) bool***REMOVED***
		func(r rune) bool ***REMOVED*** return true ***REMOVED***,        // all
		func(r rune) bool ***REMOVED*** return r < 0x80 ***REMOVED***,    // ASCII only
		func(r rune) bool ***REMOVED*** return r < 0x80 ***REMOVED***,    // ASCII only 2
		func(r rune) bool ***REMOVED*** return r <= 0xFFFF ***REMOVED***, // BMP only
		func(r rune) bool ***REMOVED*** return r > 0xFFFF ***REMOVED***,  // No BMP
	***REMOVED*** ***REMOVED***
		t := newMultiTrie(i)

		for r := rune(0); r <= unicode.MaxRune; r++ ***REMOVED***
			x := uint64(0)
			if include(r) ***REMOVED***
				x = rv[r]
			***REMOVED***
			// As we convert from a valid rune, we know it is safe to use
			// lookupStringUnsafe.
			if v := t.lookupStringUnsafe(string(r)); x != v ***REMOVED***
				fmt.Println("FAILURE")
				return
			***REMOVED***
		***REMOVED***
	***REMOVED***
	fmt.Println("SUCCESS")

	// Output:
	// SUCCESS
***REMOVED***
