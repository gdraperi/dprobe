// Copyright 2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

// This program generates the trie for idna operations. The Unicode casing
// algorithm requires the lookup of various properties and mappings for each
// rune. The table generated by this generator combines several of the most
// frequently used of these into a single trie so that they can be accessed
// with a single lookup.
package main

import (
	"fmt"
	"io"
	"log"
	"unicode"
	"unicode/utf8"

	"golang.org/x/text/internal/gen"
	"golang.org/x/text/internal/triegen"
	"golang.org/x/text/internal/ucd"
	"golang.org/x/text/unicode/bidi"
)

func main() ***REMOVED***
	gen.Init()
	genTables()
	gen.Repackage("gen_trieval.go", "trieval.go", "idna")
	gen.Repackage("gen_common.go", "common_test.go", "idna")
***REMOVED***

var runes = map[rune]info***REMOVED******REMOVED***

func genTables() ***REMOVED***
	t := triegen.NewTrie("idna")

	ucd.Parse(gen.OpenUCDFile("DerivedNormalizationProps.txt"), func(p *ucd.Parser) ***REMOVED***
		r := p.Rune(0)
		if p.String(1) == "NFC_QC" ***REMOVED*** // p.String(2) is "N" or "M"
			runes[r] = mayNeedNorm
		***REMOVED***
	***REMOVED***)
	ucd.Parse(gen.OpenUCDFile("UnicodeData.txt"), func(p *ucd.Parser) ***REMOVED***
		r := p.Rune(0)

		const cccVirama = 9
		if p.Int(ucd.CanonicalCombiningClass) == cccVirama ***REMOVED***
			runes[p.Rune(0)] = viramaModifier
		***REMOVED***
		switch ***REMOVED***
		case unicode.In(r, unicode.Mark):
			runes[r] |= modifier | mayNeedNorm
		***REMOVED***
		// TODO: by using UnicodeData.txt we don't mark undefined codepoints
		// that are earmarked as RTL properly. However, an undefined cp will
		// always fail, so there is no need to store this info.
		switch p, _ := bidi.LookupRune(r); p.Class() ***REMOVED***
		case bidi.R, bidi.AL, bidi.AN:
			if x := runes[r]; x != 0 && x != mayNeedNorm ***REMOVED***
				log.Fatalf("%U: rune both modifier and RTL letter/number", r)
			***REMOVED***
			runes[r] = rtl
		***REMOVED***
	***REMOVED***)

	ucd.Parse(gen.OpenUCDFile("extracted/DerivedJoiningType.txt"), func(p *ucd.Parser) ***REMOVED***
		switch v := p.String(1); v ***REMOVED***
		case "L", "D", "T", "R":
			runes[p.Rune(0)] |= joinType[v] << joinShift
		***REMOVED***
	***REMOVED***)

	ucd.Parse(gen.OpenUnicodeFile("idna", "", "IdnaMappingTable.txt"), func(p *ucd.Parser) ***REMOVED***
		r := p.Rune(0)

		// The mappings table explicitly defines surrogates as invalid.
		if !utf8.ValidRune(r) ***REMOVED***
			return
		***REMOVED***

		cat := catFromEntry(p)
		isMapped := cat == mapped || cat == disallowedSTD3Mapped || cat == deviation
		if !isMapped ***REMOVED***
			// Only include additional category information for non-mapped
			// runes. The additional information is only used after mapping and
			// the bits would clash with mapping information.
			// TODO: it would be possible to inline this data and avoid
			// additional lookups. This is quite tedious, though, so let's first
			// see if we need this.
			cat |= category(runes[r])
		***REMOVED***

		s := string(p.Runes(2))
		if s != "" && !isMapped ***REMOVED***
			log.Fatalf("%U: Mapping with non-mapping category %d", r, cat)
		***REMOVED***
		t.Insert(r, uint64(makeEntry(r, s))+uint64(cat))
	***REMOVED***)

	w := gen.NewCodeWriter()
	defer w.WriteVersionedGoFile("tables.go", "idna")

	gen.WriteUnicodeVersion(w)

	w.WriteVar("mappings", string(mappings))
	w.WriteVar("xorData", string(xorData))

	sz, err := t.Gen(w, triegen.Compact(&normCompacter***REMOVED******REMOVED***))
	if err != nil ***REMOVED***
		log.Fatal(err)
	***REMOVED***
	w.Size += sz
***REMOVED***

var (
	// mappings contains replacement strings for mapped runes, each prefixed
	// with a byte containing the length of the following string.
	mappings = []byte***REMOVED******REMOVED***
	mapCache = map[string]int***REMOVED******REMOVED***

	// xorData is like mappings, except that it contains XOR data.
	// We split these two tables so that we don't get an overflow.
	xorData  = []byte***REMOVED******REMOVED***
	xorCache = map[string]int***REMOVED******REMOVED***
)

// makeEntry creates a trie entry.
func makeEntry(r rune, mapped string) info ***REMOVED***
	orig := string(r)

	if len(orig) != len(mapped) ***REMOVED***
		// Store the mapped value as is in the mappings table.
		index := len(mappings)
		if x, ok := mapCache[mapped]; ok ***REMOVED***
			index = x
		***REMOVED*** else ***REMOVED***
			mapCache[mapped] = index
			mappings = append(mappings, byte(len(mapped)))
			mappings = append(mappings, mapped...)
		***REMOVED***
		return info(index) << indexShift
	***REMOVED***

	// Create per-byte XOR mask.
	var b []byte
	for i := 0; i < len(orig); i++ ***REMOVED***
		b = append(b, orig[i]^mapped[i])
	***REMOVED***

	// Remove leading 0 bytes, but keep at least one byte.
	for ; len(b) > 1 && b[0] == 0; b = b[1:] ***REMOVED***
	***REMOVED***

	if len(b) == 1 ***REMOVED***
		return xorBit | inlineXOR | info(b[0])<<indexShift
	***REMOVED***
	mapped = string(b)

	// Store the mapped value as is in the mappings table.
	index := len(xorData)
	if x, ok := xorCache[mapped]; ok ***REMOVED***
		index = x
	***REMOVED*** else ***REMOVED***
		xorCache[mapped] = index
		xorData = append(xorData, byte(len(mapped)))
		xorData = append(xorData, mapped...)
	***REMOVED***
	return xorBit | info(index)<<indexShift
***REMOVED***

// The following code implements a triegen.Compacter that was originally
// designed for normalization. The IDNA table has some similarities with the
// norm table. Using this compacter, together with the XOR pattern approach,
// reduces the table size by roughly 100K. It can probably be compressed further
// by also including elements of the compacter used by cases, but for now it is
// good enough.

const maxSparseEntries = 16

type normCompacter struct ***REMOVED***
	sparseBlocks [][]uint64
	sparseOffset []uint16
	sparseCount  int
***REMOVED***

func mostFrequentStride(a []uint64) int ***REMOVED***
	counts := make(map[int]int)
	var v int
	for _, x := range a ***REMOVED***
		if stride := int(x) - v; v != 0 && stride >= 0 ***REMOVED***
			counts[stride]++
		***REMOVED***
		v = int(x)
	***REMOVED***
	var maxs, maxc int
	for stride, cnt := range counts ***REMOVED***
		if cnt > maxc || (cnt == maxc && stride < maxs) ***REMOVED***
			maxs, maxc = stride, cnt
		***REMOVED***
	***REMOVED***
	return maxs
***REMOVED***

func countSparseEntries(a []uint64) int ***REMOVED***
	stride := mostFrequentStride(a)
	var v, count int
	for _, tv := range a ***REMOVED***
		if int(tv)-v != stride ***REMOVED***
			if tv != 0 ***REMOVED***
				count++
			***REMOVED***
		***REMOVED***
		v = int(tv)
	***REMOVED***
	return count
***REMOVED***

func (c *normCompacter) Size(v []uint64) (sz int, ok bool) ***REMOVED***
	if n := countSparseEntries(v); n <= maxSparseEntries ***REMOVED***
		return (n+1)*4 + 2, true
	***REMOVED***
	return 0, false
***REMOVED***

func (c *normCompacter) Store(v []uint64) uint32 ***REMOVED***
	h := uint32(len(c.sparseOffset))
	c.sparseBlocks = append(c.sparseBlocks, v)
	c.sparseOffset = append(c.sparseOffset, uint16(c.sparseCount))
	c.sparseCount += countSparseEntries(v) + 1
	return h
***REMOVED***

func (c *normCompacter) Handler() string ***REMOVED***
	return "idnaSparse.lookup"
***REMOVED***

func (c *normCompacter) Print(w io.Writer) (retErr error) ***REMOVED***
	p := func(f string, x ...interface***REMOVED******REMOVED***) ***REMOVED***
		if _, err := fmt.Fprintf(w, f, x...); retErr == nil && err != nil ***REMOVED***
			retErr = err
		***REMOVED***
	***REMOVED***

	ls := len(c.sparseBlocks)
	p("// idnaSparseOffset: %d entries, %d bytes\n", ls, ls*2)
	p("var idnaSparseOffset = %#v\n\n", c.sparseOffset)

	ns := c.sparseCount
	p("// idnaSparseValues: %d entries, %d bytes\n", ns, ns*4)
	p("var idnaSparseValues = [%d]valueRange ***REMOVED***", ns)
	for i, b := range c.sparseBlocks ***REMOVED***
		p("\n// Block %#x, offset %#x", i, c.sparseOffset[i])
		var v int
		stride := mostFrequentStride(b)
		n := countSparseEntries(b)
		p("\n***REMOVED***value:%#04x,lo:%#02x***REMOVED***,", stride, uint8(n))
		for i, nv := range b ***REMOVED***
			if int(nv)-v != stride ***REMOVED***
				if v != 0 ***REMOVED***
					p(",hi:%#02x***REMOVED***,", 0x80+i-1)
				***REMOVED***
				if nv != 0 ***REMOVED***
					p("\n***REMOVED***value:%#04x,lo:%#02x", nv, 0x80+i)
				***REMOVED***
			***REMOVED***
			v = int(nv)
		***REMOVED***
		if v != 0 ***REMOVED***
			p(",hi:%#02x***REMOVED***,", 0x80+len(b)-1)
		***REMOVED***
	***REMOVED***
	p("\n***REMOVED***\n\n")
	return
***REMOVED***
