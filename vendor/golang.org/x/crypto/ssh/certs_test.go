// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package ssh

import (
	"bytes"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"net"
	"reflect"
	"testing"
	"time"

	"golang.org/x/crypto/ssh/testdata"
)

// Cert generated by ssh-keygen 6.0p1 Debian-4.
// % ssh-keygen -s ca-key -I test user-key
const exampleSSHCert = `ssh-rsa-cert-v01@openssh.com AAAAHHNzaC1yc2EtY2VydC12MDFAb3BlbnNzaC5jb20AAAAgb1srW/W3ZDjYAO45xLYAwzHBDLsJ4Ux6ICFIkTjb1LEAAAADAQABAAAAYQCkoR51poH0wE8w72cqSB8Sszx+vAhzcMdCO0wqHTj7UNENHWEXGrU0E0UQekD7U+yhkhtoyjbPOVIP7hNa6aRk/ezdh/iUnCIt4Jt1v3Z1h1P+hA4QuYFMHNB+rmjPwAcAAAAAAAAAAAAAAAEAAAAEdGVzdAAAAAAAAAAAAAAAAP//////////AAAAAAAAAIIAAAAVcGVybWl0LVgxMS1mb3J3YXJkaW5nAAAAAAAAABdwZXJtaXQtYWdlbnQtZm9yd2FyZGluZwAAAAAAAAAWcGVybWl0LXBvcnQtZm9yd2FyZGluZwAAAAAAAAAKcGVybWl0LXB0eQAAAAAAAAAOcGVybWl0LXVzZXItcmMAAAAAAAAAAAAAAHcAAAAHc3NoLXJzYQAAAAMBAAEAAABhANFS2kaktpSGc+CcmEKPyw9mJC4nZKxHKTgLVZeaGbFZOvJTNzBspQHdy7Q1uKSfktxpgjZnksiu/tFF9ngyY2KFoc+U88ya95IZUycBGCUbBQ8+bhDtw/icdDGQD5WnUwAAAG8AAAAHc3NoLXJzYQAAAGC8Y9Z2LQKhIhxf52773XaWrXdxP0t3GBVo4A10vUWiYoAGepr6rQIoGGXFxT4B9Gp+nEBJjOwKDXPrAevow0T9ca8gZN+0ykbhSrXLE5Ao48rqr3zP4O1/9P7e6gp0gw8=`

func TestParseCert(t *testing.T) ***REMOVED***
	authKeyBytes := []byte(exampleSSHCert)

	key, _, _, rest, err := ParseAuthorizedKey(authKeyBytes)
	if err != nil ***REMOVED***
		t.Fatalf("ParseAuthorizedKey: %v", err)
	***REMOVED***
	if len(rest) > 0 ***REMOVED***
		t.Errorf("rest: got %q, want empty", rest)
	***REMOVED***

	if _, ok := key.(*Certificate); !ok ***REMOVED***
		t.Fatalf("got %v (%T), want *Certificate", key, key)
	***REMOVED***

	marshaled := MarshalAuthorizedKey(key)
	// Before comparison, remove the trailing newline that
	// MarshalAuthorizedKey adds.
	marshaled = marshaled[:len(marshaled)-1]
	if !bytes.Equal(authKeyBytes, marshaled) ***REMOVED***
		t.Errorf("marshaled certificate does not match original: got %q, want %q", marshaled, authKeyBytes)
	***REMOVED***
***REMOVED***

// Cert generated by ssh-keygen OpenSSH_6.8p1 OS X 10.10.3
// % ssh-keygen -s ca -I testcert -O source-address=192.168.1.0/24 -O force-command=/bin/sleep user.pub
// user.pub key: ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDACh1rt2DXfV3hk6fszSQcQ/rueMId0kVD9U7nl8cfEnFxqOCrNT92g4laQIGl2mn8lsGZfTLg8ksHq3gkvgO3oo/0wHy4v32JeBOHTsN5AL4gfHNEhWeWb50ev47hnTsRIt9P4dxogeUo/hTu7j9+s9lLpEQXCvq6xocXQt0j8MV9qZBBXFLXVT3cWIkSqOdwt/5ZBg+1GSrc7WfCXVWgTk4a20uPMuJPxU4RQwZW6X3+O8Pqo8C3cW0OzZRFP6gUYUKUsTI5WntlS+LAxgw1mZNsozFGdbiOPRnEryE3SRldh9vjDR3tin1fGpA5P7+CEB/bqaXtG3V+F2OkqaMN
// Critical Options:
//         force-command /bin/sleep
//         source-address 192.168.1.0/24
// Extensions:
//         permit-X11-forwarding
//         permit-agent-forwarding
//         permit-port-forwarding
//         permit-pty
//         permit-user-rc
const exampleSSHCertWithOptions = `ssh-rsa-cert-v01@openssh.com AAAAHHNzaC1yc2EtY2VydC12MDFAb3BlbnNzaC5jb20AAAAgDyysCJY0XrO1n03EeRRoITnTPdjENFmWDs9X58PP3VUAAAADAQABAAABAQDACh1rt2DXfV3hk6fszSQcQ/rueMId0kVD9U7nl8cfEnFxqOCrNT92g4laQIGl2mn8lsGZfTLg8ksHq3gkvgO3oo/0wHy4v32JeBOHTsN5AL4gfHNEhWeWb50ev47hnTsRIt9P4dxogeUo/hTu7j9+s9lLpEQXCvq6xocXQt0j8MV9qZBBXFLXVT3cWIkSqOdwt/5ZBg+1GSrc7WfCXVWgTk4a20uPMuJPxU4RQwZW6X3+O8Pqo8C3cW0OzZRFP6gUYUKUsTI5WntlS+LAxgw1mZNsozFGdbiOPRnEryE3SRldh9vjDR3tin1fGpA5P7+CEB/bqaXtG3V+F2OkqaMNAAAAAAAAAAAAAAABAAAACHRlc3RjZXJ0AAAAAAAAAAAAAAAA//////////8AAABLAAAADWZvcmNlLWNvbW1hbmQAAAAOAAAACi9iaW4vc2xlZXAAAAAOc291cmNlLWFkZHJlc3MAAAASAAAADjE5Mi4xNjguMS4wLzI0AAAAggAAABVwZXJtaXQtWDExLWZvcndhcmRpbmcAAAAAAAAAF3Blcm1pdC1hZ2VudC1mb3J3YXJkaW5nAAAAAAAAABZwZXJtaXQtcG9ydC1mb3J3YXJkaW5nAAAAAAAAAApwZXJtaXQtcHR5AAAAAAAAAA5wZXJtaXQtdXNlci1yYwAAAAAAAAAAAAABFwAAAAdzc2gtcnNhAAAAAwEAAQAAAQEAwU+c5ui5A8+J/CFpjW8wCa52bEODA808WWQDCSuTG/eMXNf59v9Y8Pk0F1E9dGCosSNyVcB/hacUrc6He+i97+HJCyKavBsE6GDxrjRyxYqAlfcOXi/IVmaUGiO8OQ39d4GHrjToInKvExSUeleQyH4Y4/e27T/pILAqPFL3fyrvMLT5qU9QyIt6zIpa7GBP5+urouNavMprV3zsfIqNBbWypinOQAw823a5wN+zwXnhZrgQiHZ/USG09Y6k98y1dTVz8YHlQVR4D3lpTAsKDKJ5hCH9WU4fdf+lU8OyNGaJ/vz0XNqxcToe1l4numLTnaoSuH89pHryjqurB7lJKwAAAQ8AAAAHc3NoLXJzYQAAAQCaHvUIoPL1zWUHIXLvu96/HU1s/i4CAW2IIEuGgxCUCiFj6vyTyYtgxQxcmbfZf6eaITlS6XJZa7Qq4iaFZh75C1DXTX8labXhRSD4E2t//AIP9MC1rtQC5xo6FmbQ+BoKcDskr+mNACcbRSxs3IL3bwCfWDnIw2WbVox9ZdcthJKk4UoCW4ix4QwdHw7zlddlz++fGEEVhmTbll1SUkycGApPFBsAYRTMupUJcYPIeReBI/m8XfkoMk99bV8ZJQTAd7OekHY2/48Ff53jLmyDjP7kNw1F8OaPtkFs6dGJXta4krmaekPy87j+35In5hFj7yoOqvSbmYUkeX70/GGQ`

func TestParseCertWithOptions(t *testing.T) ***REMOVED***
	opts := map[string]string***REMOVED***
		"source-address": "192.168.1.0/24",
		"force-command":  "/bin/sleep",
	***REMOVED***
	exts := map[string]string***REMOVED***
		"permit-X11-forwarding":   "",
		"permit-agent-forwarding": "",
		"permit-port-forwarding":  "",
		"permit-pty":              "",
		"permit-user-rc":          "",
	***REMOVED***
	authKeyBytes := []byte(exampleSSHCertWithOptions)

	key, _, _, rest, err := ParseAuthorizedKey(authKeyBytes)
	if err != nil ***REMOVED***
		t.Fatalf("ParseAuthorizedKey: %v", err)
	***REMOVED***
	if len(rest) > 0 ***REMOVED***
		t.Errorf("rest: got %q, want empty", rest)
	***REMOVED***
	cert, ok := key.(*Certificate)
	if !ok ***REMOVED***
		t.Fatalf("got %v (%T), want *Certificate", key, key)
	***REMOVED***
	if !reflect.DeepEqual(cert.CriticalOptions, opts) ***REMOVED***
		t.Errorf("unexpected critical options - got %v, want %v", cert.CriticalOptions, opts)
	***REMOVED***
	if !reflect.DeepEqual(cert.Extensions, exts) ***REMOVED***
		t.Errorf("unexpected Extensions - got %v, want %v", cert.Extensions, exts)
	***REMOVED***
	marshaled := MarshalAuthorizedKey(key)
	// Before comparison, remove the trailing newline that
	// MarshalAuthorizedKey adds.
	marshaled = marshaled[:len(marshaled)-1]
	if !bytes.Equal(authKeyBytes, marshaled) ***REMOVED***
		t.Errorf("marshaled certificate does not match original: got %q, want %q", marshaled, authKeyBytes)
	***REMOVED***
***REMOVED***

func TestValidateCert(t *testing.T) ***REMOVED***
	key, _, _, _, err := ParseAuthorizedKey([]byte(exampleSSHCert))
	if err != nil ***REMOVED***
		t.Fatalf("ParseAuthorizedKey: %v", err)
	***REMOVED***
	validCert, ok := key.(*Certificate)
	if !ok ***REMOVED***
		t.Fatalf("got %v (%T), want *Certificate", key, key)
	***REMOVED***
	checker := CertChecker***REMOVED******REMOVED***
	checker.IsUserAuthority = func(k PublicKey) bool ***REMOVED***
		return bytes.Equal(k.Marshal(), validCert.SignatureKey.Marshal())
	***REMOVED***

	if err := checker.CheckCert("user", validCert); err != nil ***REMOVED***
		t.Errorf("Unable to validate certificate: %v", err)
	***REMOVED***
	invalidCert := &Certificate***REMOVED***
		Key:          testPublicKeys["rsa"],
		SignatureKey: testPublicKeys["ecdsa"],
		ValidBefore:  CertTimeInfinity,
		Signature:    &Signature***REMOVED******REMOVED***,
	***REMOVED***
	if err := checker.CheckCert("user", invalidCert); err == nil ***REMOVED***
		t.Error("Invalid cert signature passed validation")
	***REMOVED***
***REMOVED***

func TestValidateCertTime(t *testing.T) ***REMOVED***
	cert := Certificate***REMOVED***
		ValidPrincipals: []string***REMOVED***"user"***REMOVED***,
		Key:             testPublicKeys["rsa"],
		ValidAfter:      50,
		ValidBefore:     100,
	***REMOVED***

	cert.SignCert(rand.Reader, testSigners["ecdsa"])

	for ts, ok := range map[int64]bool***REMOVED***
		25:  false,
		50:  true,
		99:  true,
		100: false,
		125: false,
	***REMOVED*** ***REMOVED***
		checker := CertChecker***REMOVED***
			Clock: func() time.Time ***REMOVED*** return time.Unix(ts, 0) ***REMOVED***,
		***REMOVED***
		checker.IsUserAuthority = func(k PublicKey) bool ***REMOVED***
			return bytes.Equal(k.Marshal(),
				testPublicKeys["ecdsa"].Marshal())
		***REMOVED***

		if v := checker.CheckCert("user", &cert); (v == nil) != ok ***REMOVED***
			t.Errorf("Authenticate(%d): %v", ts, v)
		***REMOVED***
	***REMOVED***
***REMOVED***

// TODO(hanwen): tests for
//
// host keys:
// * fallbacks

func TestHostKeyCert(t *testing.T) ***REMOVED***
	cert := &Certificate***REMOVED***
		ValidPrincipals: []string***REMOVED***"hostname", "hostname.domain", "otherhost"***REMOVED***,
		Key:             testPublicKeys["rsa"],
		ValidBefore:     CertTimeInfinity,
		CertType:        HostCert,
	***REMOVED***
	cert.SignCert(rand.Reader, testSigners["ecdsa"])

	checker := &CertChecker***REMOVED***
		IsHostAuthority: func(p PublicKey, addr string) bool ***REMOVED***
			return addr == "hostname:22" && bytes.Equal(testPublicKeys["ecdsa"].Marshal(), p.Marshal())
		***REMOVED***,
	***REMOVED***

	certSigner, err := NewCertSigner(cert, testSigners["rsa"])
	if err != nil ***REMOVED***
		t.Errorf("NewCertSigner: %v", err)
	***REMOVED***

	for _, test := range []struct ***REMOVED***
		addr    string
		succeed bool
	***REMOVED******REMOVED***
		***REMOVED***addr: "hostname:22", succeed: true***REMOVED***,
		***REMOVED***addr: "otherhost:22", succeed: false***REMOVED***, // The certificate is valid for 'otherhost' as hostname, but we only recognize the authority of the signer for the address 'hostname:22'
		***REMOVED***addr: "lasthost:22", succeed: false***REMOVED***,
	***REMOVED*** ***REMOVED***
		c1, c2, err := netPipe()
		if err != nil ***REMOVED***
			t.Fatalf("netPipe: %v", err)
		***REMOVED***
		defer c1.Close()
		defer c2.Close()

		errc := make(chan error)

		go func() ***REMOVED***
			conf := ServerConfig***REMOVED***
				NoClientAuth: true,
			***REMOVED***
			conf.AddHostKey(certSigner)
			_, _, _, err := NewServerConn(c1, &conf)
			errc <- err
		***REMOVED***()

		config := &ClientConfig***REMOVED***
			User:            "user",
			HostKeyCallback: checker.CheckHostKey,
		***REMOVED***
		_, _, _, err = NewClientConn(c2, test.addr, config)

		if (err == nil) != test.succeed ***REMOVED***
			t.Fatalf("NewClientConn(%q): %v", test.addr, err)
		***REMOVED***

		err = <-errc
		if (err == nil) != test.succeed ***REMOVED***
			t.Fatalf("NewServerConn(%q): %v", test.addr, err)
		***REMOVED***
	***REMOVED***
***REMOVED***

func TestCertTypes(t *testing.T) ***REMOVED***
	var testVars = []struct ***REMOVED***
		name string
		keys func() Signer
	***REMOVED******REMOVED***
		***REMOVED***
			name: CertAlgoECDSA256v01,
			keys: func() Signer ***REMOVED***
				s, _ := ParsePrivateKey(testdata.PEMBytes["ecdsap256"])
				return s
			***REMOVED***,
		***REMOVED***,
		***REMOVED***
			name: CertAlgoECDSA384v01,
			keys: func() Signer ***REMOVED***
				s, _ := ParsePrivateKey(testdata.PEMBytes["ecdsap384"])
				return s
			***REMOVED***,
		***REMOVED***,
		***REMOVED***
			name: CertAlgoECDSA521v01,
			keys: func() Signer ***REMOVED***
				s, _ := ParsePrivateKey(testdata.PEMBytes["ecdsap521"])
				return s
			***REMOVED***,
		***REMOVED***,
		***REMOVED***
			name: CertAlgoED25519v01,
			keys: func() Signer ***REMOVED***
				s, _ := ParsePrivateKey(testdata.PEMBytes["ed25519"])
				return s
			***REMOVED***,
		***REMOVED***,
		***REMOVED***
			name: CertAlgoRSAv01,
			keys: func() Signer ***REMOVED***
				s, _ := ParsePrivateKey(testdata.PEMBytes["rsa"])
				return s
			***REMOVED***,
		***REMOVED***,
		***REMOVED***
			name: CertAlgoDSAv01,
			keys: func() Signer ***REMOVED***
				s, _ := ParsePrivateKey(testdata.PEMBytes["dsa"])
				return s
			***REMOVED***,
		***REMOVED***,
	***REMOVED***

	k, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil ***REMOVED***
		t.Fatalf("error generating host key: %v", err)
	***REMOVED***

	signer, err := NewSignerFromKey(k)
	if err != nil ***REMOVED***
		t.Fatalf("error generating signer for ssh listener: %v", err)
	***REMOVED***

	conf := &ServerConfig***REMOVED***
		PublicKeyCallback: func(c ConnMetadata, k PublicKey) (*Permissions, error) ***REMOVED***
			return new(Permissions), nil
		***REMOVED***,
	***REMOVED***
	conf.AddHostKey(signer)

	for _, m := range testVars ***REMOVED***
		t.Run(m.name, func(t *testing.T) ***REMOVED***

			c1, c2, err := netPipe()
			if err != nil ***REMOVED***
				t.Fatalf("netPipe: %v", err)
			***REMOVED***
			defer c1.Close()
			defer c2.Close()

			go NewServerConn(c1, conf)

			priv := m.keys()
			if err != nil ***REMOVED***
				t.Fatalf("error generating ssh pubkey: %v", err)
			***REMOVED***

			cert := &Certificate***REMOVED***
				CertType: UserCert,
				Key:      priv.PublicKey(),
			***REMOVED***
			cert.SignCert(rand.Reader, priv)

			certSigner, err := NewCertSigner(cert, priv)
			if err != nil ***REMOVED***
				t.Fatalf("error generating cert signer: %v", err)
			***REMOVED***

			config := &ClientConfig***REMOVED***
				User:            "user",
				HostKeyCallback: func(h string, r net.Addr, k PublicKey) error ***REMOVED*** return nil ***REMOVED***,
				Auth:            []AuthMethod***REMOVED***PublicKeys(certSigner)***REMOVED***,
			***REMOVED***

			_, _, _, err = NewClientConn(c2, "", config)
			if err != nil ***REMOVED***
				t.Fatalf("error connecting: %v", err)
			***REMOVED***
		***REMOVED***)
	***REMOVED***
***REMOVED***
