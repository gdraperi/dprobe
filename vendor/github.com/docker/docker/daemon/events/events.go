package events

import (
	"sync"
	"time"

	eventtypes "github.com/docker/docker/api/types/events"
	"github.com/docker/docker/pkg/pubsub"
)

const (
	eventsLimit = 256
	bufferSize  = 1024
)

// Events is pubsub channel for events generated by the engine.
type Events struct ***REMOVED***
	mu     sync.Mutex
	events []eventtypes.Message
	pub    *pubsub.Publisher
***REMOVED***

// New returns new *Events instance
func New() *Events ***REMOVED***
	return &Events***REMOVED***
		events: make([]eventtypes.Message, 0, eventsLimit),
		pub:    pubsub.NewPublisher(100*time.Millisecond, bufferSize),
	***REMOVED***
***REMOVED***

// Subscribe adds new listener to events, returns slice of 256 stored
// last events, a channel in which you can expect new events (in form
// of interface***REMOVED******REMOVED***, so you need type assertion), and a function to call
// to stop the stream of events.
func (e *Events) Subscribe() ([]eventtypes.Message, chan interface***REMOVED******REMOVED***, func()) ***REMOVED***
	eventSubscribers.Inc()
	e.mu.Lock()
	current := make([]eventtypes.Message, len(e.events))
	copy(current, e.events)
	l := e.pub.Subscribe()
	e.mu.Unlock()

	cancel := func() ***REMOVED***
		e.Evict(l)
	***REMOVED***
	return current, l, cancel
***REMOVED***

// SubscribeTopic adds new listener to events, returns slice of 256 stored
// last events, a channel in which you can expect new events (in form
// of interface***REMOVED******REMOVED***, so you need type assertion).
func (e *Events) SubscribeTopic(since, until time.Time, ef *Filter) ([]eventtypes.Message, chan interface***REMOVED******REMOVED***) ***REMOVED***
	eventSubscribers.Inc()
	e.mu.Lock()

	var topic func(m interface***REMOVED******REMOVED***) bool
	if ef != nil && ef.filter.Len() > 0 ***REMOVED***
		topic = func(m interface***REMOVED******REMOVED***) bool ***REMOVED*** return ef.Include(m.(eventtypes.Message)) ***REMOVED***
	***REMOVED***

	buffered := e.loadBufferedEvents(since, until, topic)

	var ch chan interface***REMOVED******REMOVED***
	if topic != nil ***REMOVED***
		ch = e.pub.SubscribeTopic(topic)
	***REMOVED*** else ***REMOVED***
		// Subscribe to all events if there are no filters
		ch = e.pub.Subscribe()
	***REMOVED***

	e.mu.Unlock()
	return buffered, ch
***REMOVED***

// Evict evicts listener from pubsub
func (e *Events) Evict(l chan interface***REMOVED******REMOVED***) ***REMOVED***
	eventSubscribers.Dec()
	e.pub.Evict(l)
***REMOVED***

// Log creates a local scope message and publishes it
func (e *Events) Log(action, eventType string, actor eventtypes.Actor) ***REMOVED***
	now := time.Now().UTC()
	jm := eventtypes.Message***REMOVED***
		Action:   action,
		Type:     eventType,
		Actor:    actor,
		Scope:    "local",
		Time:     now.Unix(),
		TimeNano: now.UnixNano(),
	***REMOVED***

	// fill deprecated fields for container and images
	switch eventType ***REMOVED***
	case eventtypes.ContainerEventType:
		jm.ID = actor.ID
		jm.Status = action
		jm.From = actor.Attributes["image"]
	case eventtypes.ImageEventType:
		jm.ID = actor.ID
		jm.Status = action
	***REMOVED***

	e.PublishMessage(jm)
***REMOVED***

// PublishMessage broadcasts event to listeners. Each listener has 100 milliseconds to
// receive the event or it will be skipped.
func (e *Events) PublishMessage(jm eventtypes.Message) ***REMOVED***
	eventsCounter.Inc()

	e.mu.Lock()
	if len(e.events) == cap(e.events) ***REMOVED***
		// discard oldest event
		copy(e.events, e.events[1:])
		e.events[len(e.events)-1] = jm
	***REMOVED*** else ***REMOVED***
		e.events = append(e.events, jm)
	***REMOVED***
	e.mu.Unlock()
	e.pub.Publish(jm)
***REMOVED***

// SubscribersCount returns number of event listeners
func (e *Events) SubscribersCount() int ***REMOVED***
	return e.pub.Len()
***REMOVED***

// loadBufferedEvents iterates over the cached events in the buffer
// and returns those that were emitted between two specific dates.
// It uses `time.Unix(seconds, nanoseconds)` to generate valid dates with those arguments.
// It filters those buffered messages with a topic function if it's not nil, otherwise it adds all messages.
func (e *Events) loadBufferedEvents(since, until time.Time, topic func(interface***REMOVED******REMOVED***) bool) []eventtypes.Message ***REMOVED***
	var buffered []eventtypes.Message
	if since.IsZero() && until.IsZero() ***REMOVED***
		return buffered
	***REMOVED***

	var sinceNanoUnix int64
	if !since.IsZero() ***REMOVED***
		sinceNanoUnix = since.UnixNano()
	***REMOVED***

	var untilNanoUnix int64
	if !until.IsZero() ***REMOVED***
		untilNanoUnix = until.UnixNano()
	***REMOVED***

	for i := len(e.events) - 1; i >= 0; i-- ***REMOVED***
		ev := e.events[i]

		if ev.TimeNano < sinceNanoUnix ***REMOVED***
			break
		***REMOVED***

		if untilNanoUnix > 0 && ev.TimeNano > untilNanoUnix ***REMOVED***
			continue
		***REMOVED***

		if topic == nil || topic(ev) ***REMOVED***
			buffered = append([]eventtypes.Message***REMOVED***ev***REMOVED***, buffered...)
		***REMOVED***
	***REMOVED***
	return buffered
***REMOVED***
