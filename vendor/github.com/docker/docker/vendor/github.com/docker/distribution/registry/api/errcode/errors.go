package errcode

import (
	"encoding/json"
	"fmt"
	"strings"
)

// ErrorCoder is the base interface for ErrorCode and Error allowing
// users of each to just call ErrorCode to get the real ID of each
type ErrorCoder interface ***REMOVED***
	ErrorCode() ErrorCode
***REMOVED***

// ErrorCode represents the error type. The errors are serialized via strings
// and the integer format may change and should *never* be exported.
type ErrorCode int

var _ error = ErrorCode(0)

// ErrorCode just returns itself
func (ec ErrorCode) ErrorCode() ErrorCode ***REMOVED***
	return ec
***REMOVED***

// Error returns the ID/Value
func (ec ErrorCode) Error() string ***REMOVED***
	// NOTE(stevvooe): Cannot use message here since it may have unpopulated args.
	return strings.ToLower(strings.Replace(ec.String(), "_", " ", -1))
***REMOVED***

// Descriptor returns the descriptor for the error code.
func (ec ErrorCode) Descriptor() ErrorDescriptor ***REMOVED***
	d, ok := errorCodeToDescriptors[ec]

	if !ok ***REMOVED***
		return ErrorCodeUnknown.Descriptor()
	***REMOVED***

	return d
***REMOVED***

// String returns the canonical identifier for this error code.
func (ec ErrorCode) String() string ***REMOVED***
	return ec.Descriptor().Value
***REMOVED***

// Message returned the human-readable error message for this error code.
func (ec ErrorCode) Message() string ***REMOVED***
	return ec.Descriptor().Message
***REMOVED***

// MarshalText encodes the receiver into UTF-8-encoded text and returns the
// result.
func (ec ErrorCode) MarshalText() (text []byte, err error) ***REMOVED***
	return []byte(ec.String()), nil
***REMOVED***

// UnmarshalText decodes the form generated by MarshalText.
func (ec *ErrorCode) UnmarshalText(text []byte) error ***REMOVED***
	desc, ok := idToDescriptors[string(text)]

	if !ok ***REMOVED***
		desc = ErrorCodeUnknown.Descriptor()
	***REMOVED***

	*ec = desc.Code

	return nil
***REMOVED***

// WithMessage creates a new Error struct based on the passed-in info and
// overrides the Message property.
func (ec ErrorCode) WithMessage(message string) Error ***REMOVED***
	return Error***REMOVED***
		Code:    ec,
		Message: message,
	***REMOVED***
***REMOVED***

// WithDetail creates a new Error struct based on the passed-in info and
// set the Detail property appropriately
func (ec ErrorCode) WithDetail(detail interface***REMOVED******REMOVED***) Error ***REMOVED***
	return Error***REMOVED***
		Code:    ec,
		Message: ec.Message(),
	***REMOVED***.WithDetail(detail)
***REMOVED***

// WithArgs creates a new Error struct and sets the Args slice
func (ec ErrorCode) WithArgs(args ...interface***REMOVED******REMOVED***) Error ***REMOVED***
	return Error***REMOVED***
		Code:    ec,
		Message: ec.Message(),
	***REMOVED***.WithArgs(args...)
***REMOVED***

// Error provides a wrapper around ErrorCode with extra Details provided.
type Error struct ***REMOVED***
	Code    ErrorCode   `json:"code"`
	Message string      `json:"message"`
	Detail  interface***REMOVED******REMOVED*** `json:"detail,omitempty"`

	// TODO(duglin): See if we need an "args" property so we can do the
	// variable substitution right before showing the message to the user
***REMOVED***

var _ error = Error***REMOVED******REMOVED***

// ErrorCode returns the ID/Value of this Error
func (e Error) ErrorCode() ErrorCode ***REMOVED***
	return e.Code
***REMOVED***

// Error returns a human readable representation of the error.
func (e Error) Error() string ***REMOVED***
	return fmt.Sprintf("%s: %s", e.Code.Error(), e.Message)
***REMOVED***

// WithDetail will return a new Error, based on the current one, but with
// some Detail info added
func (e Error) WithDetail(detail interface***REMOVED******REMOVED***) Error ***REMOVED***
	return Error***REMOVED***
		Code:    e.Code,
		Message: e.Message,
		Detail:  detail,
	***REMOVED***
***REMOVED***

// WithArgs uses the passed-in list of interface***REMOVED******REMOVED*** as the substitution
// variables in the Error's Message string, but returns a new Error
func (e Error) WithArgs(args ...interface***REMOVED******REMOVED***) Error ***REMOVED***
	return Error***REMOVED***
		Code:    e.Code,
		Message: fmt.Sprintf(e.Code.Message(), args...),
		Detail:  e.Detail,
	***REMOVED***
***REMOVED***

// ErrorDescriptor provides relevant information about a given error code.
type ErrorDescriptor struct ***REMOVED***
	// Code is the error code that this descriptor describes.
	Code ErrorCode

	// Value provides a unique, string key, often captilized with
	// underscores, to identify the error code. This value is used as the
	// keyed value when serializing api errors.
	Value string

	// Message is a short, human readable decription of the error condition
	// included in API responses.
	Message string

	// Description provides a complete account of the errors purpose, suitable
	// for use in documentation.
	Description string

	// HTTPStatusCode provides the http status code that is associated with
	// this error condition.
	HTTPStatusCode int
***REMOVED***

// ParseErrorCode returns the value by the string error code.
// `ErrorCodeUnknown` will be returned if the error is not known.
func ParseErrorCode(value string) ErrorCode ***REMOVED***
	ed, ok := idToDescriptors[value]
	if ok ***REMOVED***
		return ed.Code
	***REMOVED***

	return ErrorCodeUnknown
***REMOVED***

// Errors provides the envelope for multiple errors and a few sugar methods
// for use within the application.
type Errors []error

var _ error = Errors***REMOVED******REMOVED***

func (errs Errors) Error() string ***REMOVED***
	switch len(errs) ***REMOVED***
	case 0:
		return "<nil>"
	case 1:
		return errs[0].Error()
	default:
		msg := "errors:\n"
		for _, err := range errs ***REMOVED***
			msg += err.Error() + "\n"
		***REMOVED***
		return msg
	***REMOVED***
***REMOVED***

// Len returns the current number of errors.
func (errs Errors) Len() int ***REMOVED***
	return len(errs)
***REMOVED***

// MarshalJSON converts slice of error, ErrorCode or Error into a
// slice of Error - then serializes
func (errs Errors) MarshalJSON() ([]byte, error) ***REMOVED***
	var tmpErrs struct ***REMOVED***
		Errors []Error `json:"errors,omitempty"`
	***REMOVED***

	for _, daErr := range errs ***REMOVED***
		var err Error

		switch daErr.(type) ***REMOVED***
		case ErrorCode:
			err = daErr.(ErrorCode).WithDetail(nil)
		case Error:
			err = daErr.(Error)
		default:
			err = ErrorCodeUnknown.WithDetail(daErr)

		***REMOVED***

		// If the Error struct was setup and they forgot to set the
		// Message field (meaning its "") then grab it from the ErrCode
		msg := err.Message
		if msg == "" ***REMOVED***
			msg = err.Code.Message()
		***REMOVED***

		tmpErrs.Errors = append(tmpErrs.Errors, Error***REMOVED***
			Code:    err.Code,
			Message: msg,
			Detail:  err.Detail,
		***REMOVED***)
	***REMOVED***

	return json.Marshal(tmpErrs)
***REMOVED***

// UnmarshalJSON deserializes []Error and then converts it into slice of
// Error or ErrorCode
func (errs *Errors) UnmarshalJSON(data []byte) error ***REMOVED***
	var tmpErrs struct ***REMOVED***
		Errors []Error
	***REMOVED***

	if err := json.Unmarshal(data, &tmpErrs); err != nil ***REMOVED***
		return err
	***REMOVED***

	var newErrs Errors
	for _, daErr := range tmpErrs.Errors ***REMOVED***
		// If Message is empty or exactly matches the Code's message string
		// then just use the Code, no need for a full Error struct
		if daErr.Detail == nil && (daErr.Message == "" || daErr.Message == daErr.Code.Message()) ***REMOVED***
			// Error's w/o details get converted to ErrorCode
			newErrs = append(newErrs, daErr.Code)
		***REMOVED*** else ***REMOVED***
			// Error's w/ details are untouched
			newErrs = append(newErrs, Error***REMOVED***
				Code:    daErr.Code,
				Message: daErr.Message,
				Detail:  daErr.Detail,
			***REMOVED***)
		***REMOVED***
	***REMOVED***

	*errs = newErrs
	return nil
***REMOVED***
