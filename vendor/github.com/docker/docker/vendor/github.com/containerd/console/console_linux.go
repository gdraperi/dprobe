// +build linux

package console

import (
	"io"
	"os"
	"sync"

	"golang.org/x/sys/unix"
)

const (
	maxEvents = 128
)

// Epoller manages multiple epoll consoles using edge-triggered epoll api so we
// dont have to deal with repeated wake-up of EPOLLER or EPOLLHUP.
// For more details, see:
// - https://github.com/systemd/systemd/pull/4262
// - https://github.com/moby/moby/issues/27202
//
// Example usage of Epoller and EpollConsole can be as follow:
//
//	epoller, _ := NewEpoller()
//	epollConsole, _ := epoller.Add(console)
//	go epoller.Wait()
//	var (
//		b  bytes.Buffer
//		wg sync.WaitGroup
//	)
//	wg.Add(1)
//	go func() ***REMOVED***
//		io.Copy(&b, epollConsole)
//		wg.Done()
//	***REMOVED***()
//	// perform I/O on the console
//	epollConsole.Shutdown(epoller.CloseConsole)
//	wg.Wait()
//	epollConsole.Close()
type Epoller struct ***REMOVED***
	efd       int
	mu        sync.Mutex
	fdMapping map[int]*EpollConsole
***REMOVED***

// NewEpoller returns an instance of epoller with a valid epoll fd.
func NewEpoller() (*Epoller, error) ***REMOVED***
	efd, err := unix.EpollCreate1(unix.EPOLL_CLOEXEC)
	if err != nil ***REMOVED***
		return nil, err
	***REMOVED***
	return &Epoller***REMOVED***
		efd:       efd,
		fdMapping: make(map[int]*EpollConsole),
	***REMOVED***, nil
***REMOVED***

// Add creates a epoll console based on the provided console. The console will
// be registered with EPOLLET (i.e. using edge-triggered notification) and its
// file descriptor will be set to non-blocking mode. After this, user should use
// the return console to perform I/O.
func (e *Epoller) Add(console Console) (*EpollConsole, error) ***REMOVED***
	sysfd := int(console.Fd())
	// Set sysfd to non-blocking mode
	if err := unix.SetNonblock(sysfd, true); err != nil ***REMOVED***
		return nil, err
	***REMOVED***

	ev := unix.EpollEvent***REMOVED***
		Events: unix.EPOLLIN | unix.EPOLLOUT | unix.EPOLLRDHUP | unix.EPOLLET,
		Fd:     int32(sysfd),
	***REMOVED***
	if err := unix.EpollCtl(e.efd, unix.EPOLL_CTL_ADD, sysfd, &ev); err != nil ***REMOVED***
		return nil, err
	***REMOVED***
	ef := &EpollConsole***REMOVED***
		Console: console,
		sysfd:   sysfd,
		readc:   sync.NewCond(&sync.Mutex***REMOVED******REMOVED***),
		writec:  sync.NewCond(&sync.Mutex***REMOVED******REMOVED***),
	***REMOVED***
	e.mu.Lock()
	e.fdMapping[sysfd] = ef
	e.mu.Unlock()
	return ef, nil
***REMOVED***

// Wait starts the loop to wait for its consoles' notifications and signal
// appropriate console that it can perform I/O.
func (e *Epoller) Wait() error ***REMOVED***
	events := make([]unix.EpollEvent, maxEvents)
	for ***REMOVED***
		n, err := unix.EpollWait(e.efd, events, -1)
		if err != nil ***REMOVED***
			// EINTR: The call was interrupted by a signal handler before either
			// any of the requested events occurred or the timeout expired
			if err == unix.EINTR ***REMOVED***
				continue
			***REMOVED***
			return err
		***REMOVED***
		for i := 0; i < n; i++ ***REMOVED***
			ev := &events[i]
			// the console is ready to be read from
			if ev.Events&(unix.EPOLLIN|unix.EPOLLHUP|unix.EPOLLERR) != 0 ***REMOVED***
				if epfile := e.getConsole(int(ev.Fd)); epfile != nil ***REMOVED***
					epfile.signalRead()
				***REMOVED***
			***REMOVED***
			// the console is ready to be written to
			if ev.Events&(unix.EPOLLOUT|unix.EPOLLHUP|unix.EPOLLERR) != 0 ***REMOVED***
				if epfile := e.getConsole(int(ev.Fd)); epfile != nil ***REMOVED***
					epfile.signalWrite()
				***REMOVED***
			***REMOVED***
		***REMOVED***
	***REMOVED***
***REMOVED***

// Close unregister the console's file descriptor from epoll interface
func (e *Epoller) CloseConsole(fd int) error ***REMOVED***
	e.mu.Lock()
	defer e.mu.Unlock()
	delete(e.fdMapping, fd)
	return unix.EpollCtl(e.efd, unix.EPOLL_CTL_DEL, fd, &unix.EpollEvent***REMOVED******REMOVED***)
***REMOVED***

func (e *Epoller) getConsole(sysfd int) *EpollConsole ***REMOVED***
	e.mu.Lock()
	f := e.fdMapping[sysfd]
	e.mu.Unlock()
	return f
***REMOVED***

// Close the epoll fd
func (e *Epoller) Close() error ***REMOVED***
	return unix.Close(e.efd)
***REMOVED***

// EpollConsole acts like a console but register its file descriptor with a
// epoll fd and uses epoll API to perform I/O.
type EpollConsole struct ***REMOVED***
	Console
	readc  *sync.Cond
	writec *sync.Cond
	sysfd  int
	closed bool
***REMOVED***

// Read reads up to len(p) bytes into p. It returns the number of bytes read
// (0 <= n <= len(p)) and any error encountered.
//
// If the console's read returns EAGAIN or EIO, we assumes that its a
// temporary error because the other side went away and wait for the signal
// generated by epoll event to continue.
func (ec *EpollConsole) Read(p []byte) (n int, err error) ***REMOVED***
	var read int
	ec.readc.L.Lock()
	defer ec.readc.L.Unlock()
	for ***REMOVED***
		read, err = ec.Console.Read(p[n:])
		n += read
		if err != nil ***REMOVED***
			var hangup bool
			if perr, ok := err.(*os.PathError); ok ***REMOVED***
				hangup = (perr.Err == unix.EAGAIN || perr.Err == unix.EIO)
			***REMOVED*** else ***REMOVED***
				hangup = (err == unix.EAGAIN || err == unix.EIO)
			***REMOVED***
			// if the other end disappear, assume this is temporary and wait for the
			// signal to continue again. Unless we didnt read anything and the
			// console is already marked as closed then we should exit
			if hangup && !(n == 0 && len(p) > 0 && ec.closed) ***REMOVED***
				ec.readc.Wait()
				continue
			***REMOVED***
		***REMOVED***
		break
	***REMOVED***
	// if we didnt read anything then return io.EOF to end gracefully
	if n == 0 && len(p) > 0 && err == nil ***REMOVED***
		err = io.EOF
	***REMOVED***
	// signal for others that we finished the read
	ec.readc.Signal()
	return n, err
***REMOVED***

// Writes len(p) bytes from p to the console. It returns the number of bytes
// written from p (0 <= n <= len(p)) and any error encountered that caused
// the write to stop early.
//
// If writes to the console returns EAGAIN or EIO, we assumes that its a
// temporary error because the other side went away and wait for the signal
// generated by epoll event to continue.
func (ec *EpollConsole) Write(p []byte) (n int, err error) ***REMOVED***
	var written int
	ec.writec.L.Lock()
	defer ec.writec.L.Unlock()
	for ***REMOVED***
		written, err = ec.Console.Write(p[n:])
		n += written
		if err != nil ***REMOVED***
			var hangup bool
			if perr, ok := err.(*os.PathError); ok ***REMOVED***
				hangup = (perr.Err == unix.EAGAIN || perr.Err == unix.EIO)
			***REMOVED*** else ***REMOVED***
				hangup = (err == unix.EAGAIN || err == unix.EIO)
			***REMOVED***
			// if the other end disappear, assume this is temporary and wait for the
			// signal to continue again.
			if hangup ***REMOVED***
				ec.writec.Wait()
				continue
			***REMOVED***
		***REMOVED***
		// unrecoverable error, break the loop and return the error
		break
	***REMOVED***
	if n < len(p) && err == nil ***REMOVED***
		err = io.ErrShortWrite
	***REMOVED***
	// signal for others that we finished the write
	ec.writec.Signal()
	return n, err
***REMOVED***

// Close closed the file descriptor and signal call waiters for this fd.
// It accepts a callback which will be called with the console's fd. The
// callback typically will be used to do further cleanup such as unregister the
// console's fd from the epoll interface.
// User should call Shutdown and wait for all I/O operation to be finished
// before closing the console.
func (ec *EpollConsole) Shutdown(close func(int) error) error ***REMOVED***
	ec.readc.L.Lock()
	defer ec.readc.L.Unlock()
	ec.writec.L.Lock()
	defer ec.writec.L.Unlock()

	ec.readc.Broadcast()
	ec.writec.Broadcast()
	ec.closed = true
	return close(ec.sysfd)
***REMOVED***

// signalRead signals that the console is readable.
func (ec *EpollConsole) signalRead() ***REMOVED***
	ec.readc.Signal()
***REMOVED***

// signalWrite signals that the console is writable.
func (ec *EpollConsole) signalWrite() ***REMOVED***
	ec.writec.Signal()
***REMOVED***
