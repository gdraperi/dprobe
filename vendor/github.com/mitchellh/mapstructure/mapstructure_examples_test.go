package mapstructure

import (
	"fmt"
)

func ExampleDecode() ***REMOVED***
	type Person struct ***REMOVED***
		Name   string
		Age    int
		Emails []string
		Extra  map[string]string
	***REMOVED***

	// This input can come from anywhere, but typically comes from
	// something like decoding JSON where we're not quite sure of the
	// struct initially.
	input := map[string]interface***REMOVED******REMOVED******REMOVED***
		"name":   "Mitchell",
		"age":    91,
		"emails": []string***REMOVED***"one", "two", "three"***REMOVED***,
		"extra": map[string]string***REMOVED***
			"twitter": "mitchellh",
		***REMOVED***,
	***REMOVED***

	var result Person
	err := Decode(input, &result)
	if err != nil ***REMOVED***
		panic(err)
	***REMOVED***

	fmt.Printf("%#v", result)
	// Output:
	// mapstructure.Person***REMOVED***Name:"Mitchell", Age:91, Emails:[]string***REMOVED***"one", "two", "three"***REMOVED***, Extra:map[string]string***REMOVED***"twitter":"mitchellh"***REMOVED******REMOVED***
***REMOVED***

func ExampleDecode_errors() ***REMOVED***
	type Person struct ***REMOVED***
		Name   string
		Age    int
		Emails []string
		Extra  map[string]string
	***REMOVED***

	// This input can come from anywhere, but typically comes from
	// something like decoding JSON where we're not quite sure of the
	// struct initially.
	input := map[string]interface***REMOVED******REMOVED******REMOVED***
		"name":   123,
		"age":    "bad value",
		"emails": []int***REMOVED***1, 2, 3***REMOVED***,
	***REMOVED***

	var result Person
	err := Decode(input, &result)
	if err == nil ***REMOVED***
		panic("should have an error")
	***REMOVED***

	fmt.Println(err.Error())
	// Output:
	// 5 error(s) decoding:
	//
	// * 'Age' expected type 'int', got unconvertible type 'string'
	// * 'Emails[0]' expected type 'string', got unconvertible type 'int'
	// * 'Emails[1]' expected type 'string', got unconvertible type 'int'
	// * 'Emails[2]' expected type 'string', got unconvertible type 'int'
	// * 'Name' expected type 'string', got unconvertible type 'int'
***REMOVED***

func ExampleDecode_metadata() ***REMOVED***
	type Person struct ***REMOVED***
		Name string
		Age  int
	***REMOVED***

	// This input can come from anywhere, but typically comes from
	// something like decoding JSON where we're not quite sure of the
	// struct initially.
	input := map[string]interface***REMOVED******REMOVED******REMOVED***
		"name":  "Mitchell",
		"age":   91,
		"email": "foo@bar.com",
	***REMOVED***

	// For metadata, we make a more advanced DecoderConfig so we can
	// more finely configure the decoder that is used. In this case, we
	// just tell the decoder we want to track metadata.
	var md Metadata
	var result Person
	config := &DecoderConfig***REMOVED***
		Metadata: &md,
		Result:   &result,
	***REMOVED***

	decoder, err := NewDecoder(config)
	if err != nil ***REMOVED***
		panic(err)
	***REMOVED***

	if err := decoder.Decode(input); err != nil ***REMOVED***
		panic(err)
	***REMOVED***

	fmt.Printf("Unused keys: %#v", md.Unused)
	// Output:
	// Unused keys: []string***REMOVED***"email"***REMOVED***
***REMOVED***

func ExampleDecode_weaklyTypedInput() ***REMOVED***
	type Person struct ***REMOVED***
		Name   string
		Age    int
		Emails []string
	***REMOVED***

	// This input can come from anywhere, but typically comes from
	// something like decoding JSON, generated by a weakly typed language
	// such as PHP.
	input := map[string]interface***REMOVED******REMOVED******REMOVED***
		"name":   123,                      // number => string
		"age":    "42",                     // string => number
		"emails": map[string]interface***REMOVED******REMOVED******REMOVED******REMOVED***, // empty map => empty array
	***REMOVED***

	var result Person
	config := &DecoderConfig***REMOVED***
		WeaklyTypedInput: true,
		Result:           &result,
	***REMOVED***

	decoder, err := NewDecoder(config)
	if err != nil ***REMOVED***
		panic(err)
	***REMOVED***

	err = decoder.Decode(input)
	if err != nil ***REMOVED***
		panic(err)
	***REMOVED***

	fmt.Printf("%#v", result)
	// Output: mapstructure.Person***REMOVED***Name:"123", Age:42, Emails:[]string***REMOVED******REMOVED******REMOVED***
***REMOVED***

func ExampleDecode_tags() ***REMOVED***
	// Note that the mapstructure tags defined in the struct type
	// can indicate which fields the values are mapped to.
	type Person struct ***REMOVED***
		Name string `mapstructure:"person_name"`
		Age  int    `mapstructure:"person_age"`
	***REMOVED***

	input := map[string]interface***REMOVED******REMOVED******REMOVED***
		"person_name": "Mitchell",
		"person_age":  91,
	***REMOVED***

	var result Person
	err := Decode(input, &result)
	if err != nil ***REMOVED***
		panic(err)
	***REMOVED***

	fmt.Printf("%#v", result)
	// Output:
	// mapstructure.Person***REMOVED***Name:"Mitchell", Age:91***REMOVED***
***REMOVED***

func ExampleDecode_embeddedStruct() ***REMOVED***
	// Squashing multiple embedded structs is allowed using the squash tag.
	// This is demonstrated by creating a composite struct of multiple types
	// and decoding into it. In this case, a person can carry with it both
	// a Family and a Location, as well as their own FirstName.
	type Family struct ***REMOVED***
		LastName string
	***REMOVED***
	type Location struct ***REMOVED***
		City string
	***REMOVED***
	type Person struct ***REMOVED***
		Family    `mapstructure:",squash"`
		Location  `mapstructure:",squash"`
		FirstName string
	***REMOVED***

	input := map[string]interface***REMOVED******REMOVED******REMOVED***
		"FirstName": "Mitchell",
		"LastName":  "Hashimoto",
		"City":      "San Francisco",
	***REMOVED***

	var result Person
	err := Decode(input, &result)
	if err != nil ***REMOVED***
		panic(err)
	***REMOVED***

	fmt.Printf("%s %s, %s", result.FirstName, result.LastName, result.City)
	// Output:
	// Mitchell Hashimoto, San Francisco
***REMOVED***
